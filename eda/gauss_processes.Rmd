---
title: "Gaussian Processes"
author: "Shannon Williams"
date: "15/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r}
library(tidyverse)
library(sf)
library(raster)

devtools::load_all("chigcrim")
df <- load_data(year = 2019, na_omit = TRUE)
df$fbi_code %<>% forcats::fct_relevel(sort)
df %>% select(fbi_code, primary_type) %>% unique() %>% arrange(fbi_code)
count_df <- df %>% filter(fbi_code %in% c("03", "05", "06", "07")) %>%
  mutate(week = week(date)) %>% count(week, community_area)
avg_df <- count_df %>% group_by(community_area) %>% 
  summarise(avg_count = round(mean(n))) %>%
  mutate(normal_count = avg_count / sum(avg_count))
sum(avg_df$normal_count)
```

Community bounds geometries

```{r}
# Load shapefile containing community areas
com_bounds <- st_read("data/community_areas.shp", quiet = TRUE)
com_bounds %<>% arrange(as.integer(area_numbe))
print(com_bounds, n = 3)
plot(st_geometry(com_bounds))
```

Define the distance between two community areas as the distance between their centroids:

```{r, warning = FALSE}
dist_matrix <- st_distance(st_centroid(com_bounds))
```

Define some kernel functions.

```{r}
# Matern covariance for nu = 3/2
matern_cov <- function(dist, l, sigma) {
  sigma^2 * (1 + sqrt(3) * dist / l) * exp(- sqrt(3) * dist / l)
}

rbf_cov <- function(t1, t2, l, sigma) {
  sigma^2 * exp(- (t1 - t2)^2 / (2*l^2))
}

periodic_cov <- function(t1, t2, l, sigma) {
 sigma^2 * exp(- 2 * (sin((t1-t2) * pi / 52))^2 / l^2)
}

cov_comp <- function(dist, t1, t2, sigmas, scales) {
  k1 <- matern_cov(dist, scales[1], sigmas[1])
  k2 <- rbf_cov(t1, t2, scales[2], sigmas[2])
  k3 <- periodic_cov(t1, t2, scales[3], sigmas[3])
  k1 + k2 + k3
}
```

The covariance structure for the Gaussian process:

$$ K \left((s, t), (s', t')\right) = k_s(s, s') + k_t(t, t') + k_p(t,t') $$

where

*   $k_s(s,s')$ is a Matern covariance function with $\nu = \frac{3}{2}$, scale parameter $\ell_{s_1}$ and variance $\sigma_s^2$
*   $k_t(t,t')$ is an RBF covariance function with scale parameter $\ell_{t_1}$ and variance $\sigma_{t_1}^2$
*   $k_p(t,t')$ is a periodic covariance function with scale parameter $\ell_{t_3}$, variance $\sigma_{t_3}^2}$, and period 52:

$$ k_p(t,t') = \sigma^2 \exp \left(- \frac{2 \sin^2 \left(\frac{(t-t') \pi}{52}\right)}{\ell_{t_3}^2} \right)$$
Each hyperparameter has a prior distribution given by a Student's t-distribution with mean $\mu=0$, scale $\sigma^2=1$ and $\nu = 4$ degrees of freedom:

$$ p(x) = \frac{\Gamma\left(\frac{\nu+1}{2}\right)}{\Gamma\left(\frac{\nu}{2}\right) \sqrt{\nu \pi \sigma^2}} \left(1 + \frac{(x-\mu)^2}{\nu \sigma^2}\right)^{- \frac{\nu+1}{2}} $$
```{r}
sigma_init <- list(s = 1, t = 1, tp = 1)
scale_init <- list(s = 1, t = 1, tp = 1)
```

# lgcp

```{r}
library(spatstat)
library(lgcp)
chig_bound <- st_union(com_bounds)
# Project from WGS84 to planar coordinates
chig_owin <- chig_bound %>% st_transform(crs = 6345) %>% as.owin()
com_bounds_t <- com_bounds %>% st_transform(crs = 6345) %>% st_centroid()

# Select theft crimes
theft_df <- df %>% mutate(week = week(date)) %>% 
  filter(fbi_code %in% c("03", "05", "06", "07"))
# Use latitude and longitude as coordinates to correspond with Chicago boundary
coords <- cbind(theft_df$longitude, theft_df$latitude)
coords_list <- lapply(1:dim(coords)[1], function(i) coords[i, ])
# Convert to st points and then project to planar coordinates
st_pts <- lapply(coords_list, st_point)
st_list <- st_sfc(st_pts, crs = 4326)
proj_coords <- st_transform(st_list, crs = 6345)
# Back to a matrix
proj_mat <- st_geometry(proj_coords) %>% unlist() %>% matrix(ncol = 2, byrow = TRUE)
# Note that some points actually lie outside the boundary
# Remove these points for ease
inside <- which(inside.owin(proj_mat[,1], proj_mat[,2], chig_owin))
proj_mat <- proj_mat[inside, ]
theft_df <- theft_df[inside, ]
data <- proj_mat %>% cbind(theft_df$week)
tlim <- c(0, 53)
xyt <- stppp(list(data = data, tlim = tlim, window = chig_owin))
den <- lambdaEst(xyt, axes = TRUE)
plot(den)
sar <- spatialAtRisk(den)
gin <- ginhomAverage(xyt, spatial.intensity = sar, temporal.intensity = mut)


proj_bounds <- st_transform(com_bounds, crs = 6345)
proj_centroids <- st_centroid(com_bounds)
x <- lapply(1:77, function(i) proj_centroids$geometry[[i]][1]) %>% unlist()
y <- lapply(1:77, function(i) proj_centroids$geometry[[i]][2]) %>% unlist()
```



```{r}
x <- lapply(1:77, function(i) st_centroid(com_bounds)$geometry[[i]][1]) %>% unlist()
y <- lapply(1:77, function(i) st_centroid(com_bounds)$geometry[[i]][2]) %>% unlist()
t <- 1:52
count_df

```