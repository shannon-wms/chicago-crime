---
title: "GAM modelling"
author: "Euan Enticott"
date: "17/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = paste0(rprojroot::find_rstudio_root_file(), "/chigcrim"))
```

## Imports

```{r}
# Load required packages
library(mgcv)
library(tidyverse)
library(lubridate)
library(spatstat)
devtools::load_all()
```

## Data

For the training data we will use historical data from 2016 - 2018. We will then predict on the data from 2019 to test the model.
```{r, cache = TRUE}
# Downoad training data
crime_train <- load_data(c(2015, 2018), strings_as_factors = TRUE)
# Download test data
crime_test <- load_data(2019, strings_as_factors = TRUE)
```

It is then necessary to prepare the data for its' use within the Generalised Additive Models. 

```{r}
# Extract useful information from the date
crime_train %<>% convert_dates(exclude = "hour")
crime_test %<>% convert_dates(exclude = "hour")


# List of features to use in GAM
keep_features <- c("month", "week", "year", "day", "date", "community_area", 
                   "beat", "fbi_code", "yday")

# Prep data for use in GAM
# Use all_of(keep_features) to suppress warning message
gam_train <- crime_train %>% select(all_of(keep_features)) %>% na.omit() %>% 
  mutate(day = as.numeric(day))
gam_test <- crime_test %>% select(all_of(keep_features)) %>% na.omit() %>% 
  mutate(day = as.numeric(day))
```

We are interested in predicting the daily number of crimes, each row represents a crime thus we need to sum the rows for each day to get the number of crimes. We can use the `count` function to achieve this. Later we will look at breaking down the data further to predict how many of each type of crime (by FBI code) will occur in each commmunity area on a given day.

```{r}
# Quicker than aggregate
train_dat <- gam_train %>% count(yday, year, date) %>% arrange(year, yday)
test_dat <- gam_test %>% count(yday, year, date) %>% arrange(year, yday)
```

## Model creation

We now build the GAMs using the `mgcv` package.

```{r}
# Baseline GAM
gam1 <- gam(n ~ s(as.numeric(yday), bs = "cc") + year, data = train_dat, 
            family = "poisson")

# Store type of each data 
train_dat$Type <- "Training data"
test_dat$Type <- "Test data"
all_dat <- rbind(train_dat, test_dat)
all_dat$Type <- as.factor(all_dat$Type)

# Create plot for baseline model
base_gam_plot <- ggplot(all_dat) + geom_point(aes(date, n)) + xlab("Date") + ylab("Daily crimes") + geom_line(aes(date, predict(gam1, type = "response", newdata = all_dat), colour = Type), size = 2) + ggtitle("Baseline GAM") + theme(legend.position = c(0.9, 0.9), legend.background = element_rect(fill="lightgrey", size=0.5, linetype="solid"), legend.title = element_text(size = 13), legend.text = element_text(size = 10))

# Find accuracy
RMSE1 <- rmse_loss(predict(gam1, type = "response", newdata = test_dat), test_dat$n)
RMSE1

R2_1 <- r_squared(predict(gam1, type = "response", newdata = test_dat), test_dat$n)
R2_1

ggsave("../plots/base_gam_plot.pdf", plot = base_gam_plot, width = 9.99, height = 6.45, units = "in")

```

## Feature creation

There are several features that may be of interest, whether a day is a weekend or not, the number of crimes over the previous month, the number of crimes on the same day of the previous year. We make tables of the days with the least and most daily crimes.

```{r}
most_crimes <- train_dat %>% arrange(by = desc(n))
most_crimes$date <- as.character(most_crimes$date) #xtable doesn't handle date format
xtable(head(most_crimes[,-5]), )
```

```{r}
least_crimes <- train_dat %>% arrange(by = n)
least_crimes$date <- as.character(least_crimes$date) #xtable doesn't handle date format
xtable(head(least_crimes[,-5]), )
```

```{r}
add_prev_day <- function(dat, start_date) {
    dat$n_pre <- left_join(data.frame(date = dat$date - days(1)), dat, by = "date")$n
    dat$n_pre[is.na(dat$n_pre)] <- 0
    dat$n_pre[dat$date == start_date] <- NA
    return(dat)
}

add_prev_week <- function(dat, start_date) {
    dat$n_pre <- left_join(data.frame(date = dat$date - days(1)), dat, by = "date")$n
    dat$n_pre[is.na(dat$n_pre)] <- 0
    dat$n_pre[dat$date == start_date] <- NA
    return(dat)
}


add_dow <- function(dat) {
  dat$dow <- wday(dat$date)
  return(dat)
}

add_is_fom <- function(dat) {
  dat$is_fom <- mday(dat$date) == 1
  return(dat)
}

add_is_christmas <- function(dat) {
  dat$is_christmas <- format(dat$date, "%d-%m") == "25-12" | 
    format(dat$date, "%d-%m") == "24-12" |
    format(dat$date, "%d-%m") == "26-12"
  return(dat)
}

add_is_NYD <- function(dat) {
  dat$is_NYD <- format(dat$date, "%d-%m") == "01-01" 
  return(dat)
}

add_month <- function(dat) {
  dat$month <- month(dat$date)
  return(dat)
}

add_week <- function(dat) {
  dat$week <- week(dat$date)
  return(dat)
}



# Add features to train data
train_dat <- add_prev_day(train_dat, "2015-01-01")
train_dat <- add_dow(train_dat)
train_dat <- add_is_fom(train_dat)
train_dat <- add_is_christmas(train_dat)
train_dat <- add_is_NYD(train_dat)
train_dat <- add_month(train_dat)
train_dat <- add_week(train_dat)

data_2014 <- load_data(2014, strings_as_factors = TRUE)
data_2014 <- data_2014 %>% convert_dates(exclude = "hour") %>% count(year, date) %>% arrange(year)

train_dat[1, "n_pre"] <- data_2014[data_2014$date == "2014-12-31", "n"][1,] #fill in previous year manually

# Add features to test data
test_dat <- add_prev_day(test_dat, "2019-01-01")
test_dat <- add_dow(test_dat)
test_dat <- add_is_fom(test_dat)
test_dat <- add_is_christmas(test_dat)
test_dat <- add_is_NYD(test_dat)
test_dat <- add_month(test_dat)
test_dat <- add_week(test_dat)
test_dat[1, "n_pre"] <- train_dat[train_dat$date == "2018-12-31", "n"] #fill in previous year manually

```

```{r}
gam2 <- gam(n ~ s(as.numeric(yday), bs = "cc") + n_pre, data = train_dat, family = "poisson")

gam_plot2 <- ggplot(all_dat) + geom_point(aes(date, n)) + xlab("Date") + ylab("Daily crimes") + geom_line(aes(date, predict(gam2, type = "response", newdata = all_dat), colour = Type), size = 2, alpha = 0.4) + ggtitle("Daily GAM") + theme(legend.position = c(0.9, 0.9), legend.background = element_rect(fill="lightgrey", size=0.5, linetype="solid"), legend.title = element_text(size = 13), legend.text = element_text(size = 10))

RMSE2 <- rmse_loss(predict(gam2, type = "response", newdata = test_dat), test_dat$n)
RMSE2

R2_2 <- r_squared(predict(gam2, type = "response", newdata = test_dat), test_dat$n)
R2_2

```

```{r}
gam3 <- gam(n ~ s(as.numeric(yday), bs = "cc") + s(as.numeric(dow), bs = "cr", k = 5) + n_pre, data = train_dat, family = "poisson")

gam_plot3 <- ggplot(all_dat) + geom_point(aes(date, n)) + xlab("Date") + ylab("Daily crimes") + geom_line(aes(date, predict(gam3, type = "response", newdata = all_dat), colour = Type), size = 2, alpha = 0.4) + ggtitle("Daily GAM") + theme(legend.position = c(0.9, 0.9), legend.background = element_rect(fill="lightgrey", size=0.5, linetype="solid"), legend.title = element_text(size = 13), legend.text = element_text(size = 10))
RMSE3 <- rmse_loss(predict(gam3, type = "response", newdata = test_dat), test_dat$n)
RMSE3

R2_3 <- r_squared(predict(gam3, type = "response", newdata = test_dat), test_dat$n)
R2_3


```
```{r}
gam4 <- gam(n ~ s(as.numeric(yday), bs = "cc") + as.factor(dow) + n_pre, data = train_dat, family = "poisson")

gam_plot4 <- ggplot(all_dat) + geom_point(aes(date, n)) + xlab("Date") + ylab("Daily crimes") + geom_line(aes(date, predict(gam4, type = "response", newdata = all_dat), colour = Type), size = 2, alpha = 0.4) + ggtitle("Daily GAM") + theme(legend.position = c(0.9, 0.9), legend.background = element_rect(fill="lightgrey", size=0.5, linetype="solid"), legend.title = element_text(size = 13), legend.text = element_text(size = 10))

RMSE4 <- rmse_loss(predict(gam4, type = "response", newdata = test_dat), test_dat$n)
RMSE4

R2_4 <- r_squared(predict(gam4, type = "response", newdata = test_dat), test_dat$n)
R2_4


```

```{r}

gam5 <- gam(n ~ s(as.numeric(yday), bs = "cc") + as.factor(dow) + n_pre + is_fom + is_christmas + 
               is_NYD + as.factor(week) , data = train_dat, family = "poisson")

best_gam_plot <- ggplot(all_dat) + geom_point(aes(date, n)) + xlab("Date") + ylab("Daily crimes") + geom_line(aes(date, predict(gam5, type = "response", newdata = all_dat), colour = Type), size = 2, alpha = 0.4) + ggtitle("Daily GAM") + theme(legend.position = c(0.9, 0.9), legend.background = element_rect(fill="lightgrey", size=0.5, linetype="solid"), legend.title = element_text(size = 13), legend.text = element_text(size = 10))


RMSE5 <- rmse_loss(predict(gam5, type = "response", newdata = test_dat), test_dat$n)
RMSE5

R2_5 <- r_squared(predict(gam5, type = "response", newdata = test_dat), test_dat$n)
R2_5

plot(predict(gam5, type = "response", newdata = test_dat), test_dat$n)
abline(b = 1, a = 0, col = "red")

gam_metrics <- data.frame(RMSE = c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5), R2 = c(R2_1, R2_2, R2_3, R2_4, R2_5))

xtable(gam_metrics)

ggsave("../plots/best_gam_plot.pdf", plot = best_gam_plot, width = 9.99, height = 6.45, units = "in")
```

# Discrete Spatial Data

```{r, cache = TRUE}
library(sf)
# Load the community areas boundaries
data("community_bounds")
com_bounds <- community_bounds
com_bounds %<>% arrange(as.integer(area_numbe))
com_bounds
# Create a neighbours list
com_nb <- spdep::poly2nb(com_bounds, row.names = com_bounds$community)
names(com_nb) <- attr(com_nb, "region.id")
coords <- st_coordinates(st_centroid(st_geometry(com_bounds)))
plot(st_geometry(com_bounds), border = "grey")
plot(com_nb, coords, add = TRUE)

# Construct training data set
spatial_train <- gam_train %>% 
  mutate(community_area = factor(community_area)) %>%
  count(week, year, community_area) %>%
  arrange(year, week, community_area)

# Construct test data set
spatial_test <- gam_test %>% 
  mutate(community_area = factor(community_area)) %>%
  count(week, year, community_area) %>%
  arrange(year, week, community_area)

# Train GAM
ctrl <- gam.control(nthreads = 8)
gam_spat <- gam(n ~ s(as.numeric(week), bs = "cc") + 
      s(community_area, bs = "mrf", xt = list(nb = com_nb)),
    data = spatial_train, family = "poisson", control = ctrl)
summary(gam_spat)



spatial_dat$residual <- spatial_dat$n - predict(gam_spat, type = "response")
spatial_test$predicted <- predict(gam_spat, type = "response", newdata = spatial_test)
spatial_dat


com_area <- spatial_test %>% group_by(community_area) %>% summarise(n = sum(n), n_pred = sum(predicted))
com_area$residual <- (com_area$n - com_area$n_pred)
com_bounds$residual <- com_area$residual

p <- ggplot(com_bounds) + geom_sf(aes(fill = residual, text = community)) + 
  ggtitle("Crime frequency by community area") +
  colorspace::scale_fill_continuous_sequential(5, palette = "Inferno") + theme_void() +
  guides(fill = guide_colorbar(title = "Frequency")) +
  scale_fill_gradientn(colors = colorspace::sequential_hcl(5, palette = "Inferno")[5:1], 
                       breaks = seq(-1500, 1000, 500), limits = c(-1500, 1000))



```

```{r}
library(plotly)
plot_data <- spatial_dat %>% filter(year == 2016)
plot_data %<>% mutate(fit = predict(gam_spat, newdata = plot_data, type = "response")) %>% select(-year)
plot_data <- com_bounds %>% left_join(plot_data, by = c("area_numbe" = "community_area"))

gglayers <- list(ggtitle("Actual Counts of Crime in Chicago"),
                 colorspace::scale_fill_continuous_sequential(5, palette = "Inferno"),
                 theme_void(),
                 guides(fill = guide_colorbar(title = "Crime Count")))
p <- ggplot(data = plot_data) +
  geom_sf(aes(fill = n, text = paste0(community, ": ", n))) +
  gglayers
p %>% ggplotly(tooltip = "text") %>% 
  style(hoverlabel = list(bgcolor = "white"), 
        hoveron = "fill", traces = seq.int(2, length(p$x$data)))

p1 <- ggplot(data = plot_data, 
             aes(fill = n - fit, 
                 text = paste0(community, ": ", n - fit), 
                 frame = week)) +
  geom_sf() +
  gglayers
gg <- p1 %>% ggplotly(tooltip = "text") %>% 
  style(hoverlabel = list(bgcolor = "white"), 
        hoveron = "fill", traces = seq.int(2, length(p1$x$data))) %>%
  plotly_build()
gg$x$frames <- lapply(gg$x$frames, function(f) {
  f$data <- lapply(f$data, function(d) d[!names(d) %in% c("x", "y")])
  f
})

```

Use police beat for locations instead.

```{r, cache = TRUE}
library(sf)
# Load the community areas boundaries
beat_bounds <- st_read("data/beat_bounds.shp", quiet = TRUE)
beat_bounds %<>% arrange(as.integer(beat_num))
beat_bounds
# Create a neighbours list
beat_nb <- spdep::poly2nb(beat_bounds, row.names = beat_bounds$beat_num)
names(beat_nb) <- attr(beat_nb, "region.id")
coords <- st_coordinates(st_centroid(st_geometry(beat_bounds)))
plot(st_geometry(beat_bounds), border = "grey")
plot(beat_nb, coords, add = TRUE)
# Construct training data set
beat_dat <- gam_train %>% 
  mutate(beat = factor(beat)) %>%
  count(week, year, beat) %>%
  arrange(year, week, beat)
# Train GAM
ctrl <- gam.control(nthreads = 8)
gam_beat <- gam(n ~ s(as.numeric(week), bs = "cc") + beat,
    data = beat_dat, family = "poisson", control = ctrl)
summary(gam_beat)
```

Comparing the GAM using spatial data and a neighbourhood list with a GAM using community areas as factors.

```{r}
gam_com <- gam(n ~ s(as.numeric(week), bs = "cc") + community_area,
    data = spatial_dat, family = "poisson", control = ctrl)
summary(gam_com)
```


# Using PoissonGAM object

Initialise a `PoissonGAM` object that uses week as the time period, and community_area as the region, over which to aggregate, does not include a neighbourhood list (`community_area` used as a factor), takes `fbi_code` as factor too, and filters out any weeks > 52 for consistency.

It takes `gam_train` as the dataset, which is automatically converted to count data aggregated over the above factors. Fitting is performed in parallel over 7 threads.

```{r}
pg <- PoissonGAM$new(time_period = "week", region = "community_area",
                     crime_type = "fbi_code", include_nb = TRUE, 
                     filter_week = TRUE)
# Fit using gam_train as the dataset 
pg$fit(gam_train, n_threads = 7)
pg$gam_fitted
pg$fit_summary
# Prediction on the same dataset
pg$predict()
pg$predictions
# New object with the same properties as pg
pg1 <- pg
pg1$gam_fitted
# Prediction on test dataset instead 
pg1$predict(gam_test)
pg1$predictions
```