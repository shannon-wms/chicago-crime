---
title: "GAM modelling"
author: "Euan Enticott"
date: "17/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = paste0(rprojroot::find_rstudio_root_file(), "/chigcrim"))
```

## Imports

```{r}
library(mgcv)
library(tidyverse)
library(lubridate)
library(spatstat)
devtools::load_all()
```

## Data

For the training data we will use historical data from 2016 - 2018. We will then predict on the data from 2019 to test the model.
```{r, cache = TRUE}
# Downoad training data
crime_train <- load_data(c(2016, 2018), strings_as_factors = TRUE)
# Download test data
crime_test <- load_data(2019, strings_as_factors = TRUE)
```

It is then necessary to prepare the data for its' use within the Generalised Additive Models. 

```{r}
# Extract useful information from the date
crime_train %<>% convert_dates(exclude = "hour")
crime_test %<>% convert_dates(exclude = "hour")


# List of features to use in GAM
keep_features <- c("month", "week", "year", "day", "date", "community_area", 
                   "beat", "fbi_code", "yday")

# Prep data for use in GAM
# Use all_of(keep_features) to suppress warning message
gam_train <- crime_train %>% select(all_of(keep_features)) %>% na.omit() %>% 
  mutate(day = as.numeric(day))
gam_test <- crime_test %>% select(all_of(keep_features)) %>% na.omit() %>% 
  mutate(day = as.numeric(day))
```

We are interested in predicting the daily number of crimes, each row represents a crime thus we need to sum the rows for each day to get the number of crimes. We can use the `count` function to achieve this. Later we will look at breaking down the data further to predict how many of each type of crime (by FBI code) will occur in each commmunity area on a given day.

```{r}
# Quicker than aggregate
train_dat <- gam_train %>% count(yday, year, date) %>% arrange(year, yday)
test_dat <- gam_test %>% count(yday, year, date) %>% arrange(year, yday)
```

## Model creation

We now build the GAMs using the `mgcv` package.

```{r}
gam1 <- gam(n ~ s(as.numeric(yday), bs = "cc") + year, data = train_dat, 
            family = "poisson")
plot(train_dat$n, predict(gam1, type = "response"))
abline(a = 0, b = 1, col = "red")

plot(train_dat$date, train_dat$n)
points(train_dat$date, predict(gam1, type = "response"), col = "red")

all_dat <- rbind(train_dat, test_dat)
plot(all_dat$date, all_dat$n, xlab = "Date", ylab = "Daily crimes")
points(all_dat$date, predict(gam1, type = "response", newdata = all_dat), 
       col = c(rep("red", nrow(train_dat)), rep("blue", nrow(test_dat))))
abline(v = date("2019-01-01"), lty = "dashed")
```

## Feature creation

There are several features that may be of interest, whether a day is a weekend or not, the number of crimes over the previous month, the number of crimes on the same day of the previous year. 

```{r}
add_prev_day <- function(dat, start_date) {
    dat$n_pre <- left_join(data.frame(date = dat$date - days(1)), dat, by = "date")$n
    dat$n_pre[is.na(dat$n_pre)] <- 0
    dat$n_pre[dat$date == start_date] <- NA
    return(dat)
}

add_prev_week <- function(dat, start_date) {
    dat$n_pre <- left_join(data.frame(date = dat$date - days(1)), dat, by = "date")$n
    dat$n_pre[is.na(dat$n_pre)] <- 0
    dat$n_pre[dat$date == start_date] <- NA
    return(dat)
}


add_dow <- function(dat) {
  dat$dow <- wday(dat$date)
  return(dat)
}

add_is_fom <- function(dat) {
  dat$is_fom <- mday(dat$date) == 1
  return(dat)
}

add_is_christmas <- function(dat) {
  dat$is_christmas <- format(dat$date, "%d-%m") == "25-12" | 
    format(dat$date, "%d-%m") == "24-12" |
    format(dat$date, "%d-%m") == "26-12"
  return(dat)
}

add_is_NYD <- function(dat) {
  dat$is_NYD <- format(dat$date, "%d-%m") == "01-01" 
  return(dat)
}

add_month <- function(dat) {
  dat$month <- month(dat$date)
  return(dat)
}

add_is_jan <- function(dat) {
  dat$is_jan <- month(dat$date) == 1
  return(dat)
}

add_week <- function(dat) {
  dat$week <- week(dat$date)
  return(dat)
}

train_dat <- add_prev_day(train_dat, "2016-01-01")
train_dat <- add_dow(train_dat)
train_dat <- add_is_fom(train_dat)
train_dat <- add_is_christmas(train_dat)
train_dat <- add_is_NYD(train_dat)
train_dat <- add_month(train_dat)
train_dat <- add_is_jan(train_dat)
train_dat <- add_week(train_dat)
```

```{r}
gam2 <- gam(n ~ s(as.numeric(yday), bs = "cc") + n_pre, data = train_dat, family = "poisson")
plot(train_dat$date, train_dat$n, xlim = c(date("2016-02-01"), date("2016-02-28")))
points(train_dat$date[-1], predict(gam2, type = "response"), col = "red")
plot(train_dat$date, train_dat$n)
points(train_dat$date[-1], predict(gam2, type = "response"), col = "red")

```

```{r}
gam3 <- gam(n ~ s(as.numeric(yday), bs = "cc") + s(as.numeric(dow), bs = "cr", k = 5) + n_pre, data = train_dat, family = "poisson")
plot(train_dat$date, train_dat$n, xlim = c(date("2016-02-01"), date("2016-02-28")))
points(train_dat$date[-1], predict(gam3, type = "response"), col = "red")
plot(train_dat$date, train_dat$n)
points(train_dat$date[-1], predict(gam3, type = "response"), col = "red")
```
```{r}
gam4 <- gam(n ~ s(as.numeric(yday), bs = "cc") + as.factor(dow) + n_pre, data = train_dat, family = "poisson")
plot(train_dat$date, train_dat$n, xlim = c(date("2017-12-01"), date("2018-02-28")))
points(train_dat$date[-1], predict(gam4, type = "response"), col = "red")
plot(train_dat$date, train_dat$n)
points(train_dat$date[-1], predict(gam4, type = "response"), col = "red")
```

```{r}
gam5 <- gam(n ~ s(as.numeric(yday), bs = "cc") + as.factor(dow) + n_pre + is_fom + is_christmas + 
              is_jan + is_NYD + as.factor(week), data = train_dat, family = "poisson")
plot(train_dat$date, train_dat$n, xlim = c(date("2016-02-01"), date("2016-02-28")))
points(train_dat$date[-1], predict(gam5, type = "response"), col = "red")
plot(train_dat$date, train_dat$n)
points(train_dat$date[-1], predict(gam5, type = "response"), col = "red")
plot(train_dat$date[-1], train_dat$n[-1] - predict(gam5, type = "response"))
```

# Discrete Spatial Data

```{r, cache = TRUE}
library(sf)
# Load the community areas boundaries
com_bounds <- st_read("data/community_areas.shp", quiet = TRUE)
com_bounds %<>% arrange(as.integer(area_numbe))
com_bounds
# Create a neighbours list
com_nb <- spdep::poly2nb(com_bounds, row.names = com_bounds$community)
names(com_nb) <- attr(com_nb, "region.id")
coords <- st_coordinates(st_centroid(st_geometry(com_bounds)))
plot(st_geometry(com_bounds), border = "grey")
plot(com_nb, coords, add = TRUE)

# Construct training data set
spatial_dat <- gam_train %>% 
  mutate(community_area = factor(community_area)) %>%
  count(week, year, community_area) %>%
  arrange(year, week, community_area)
# Train GAM
ctrl <- gam.control(nthreads = 8)
gam_spat <- gam(n ~ s(as.numeric(week), bs = "cc") + 
      s(community_area, bs = "mrf", xt = list(nb = com_nb)),
    data = spatial_dat, family = "poisson", control = ctrl)
summary(gam_spat)
```

```{r}
library(plotly)
plot_data <- spatial_dat %>% filter(year == 2016)
plot_data %<>% mutate(fit = predict(gam_spat, newdata = plot_data, type = "response")) %>% select(-year)
plot_data <- com_bounds %>% left_join(plot_data, by = c("area_numbe" = "community_area"))

gglayers <- list(ggtitle("Actual Counts of Crime in Chicago"),
                 colorspace::scale_fill_continuous_sequential(5, palette = "Inferno"),
                 theme_void(),
                 guides(fill = guide_colorbar(title = "Crime Count")))
p <- ggplot(data = plot_data) +
  geom_sf(aes(fill = n, text = paste0(community, ": ", n))) +
  gglayers
p %>% ggplotly(tooltip = "text") %>% 
  style(hoverlabel = list(bgcolor = "white"), 
        hoveron = "fill", traces = seq.int(2, length(p$x$data)))

p1 <- ggplot(data = plot_data, 
             aes(fill = n - fit, 
                 text = paste0(community, ": ", n - fit), 
                 frame = week)) +
  geom_sf() +
  gglayers
gg <- p1 %>% ggplotly(tooltip = "text") %>% 
  style(hoverlabel = list(bgcolor = "white"), 
        hoveron = "fill", traces = seq.int(2, length(p1$x$data))) %>%
  plotly_build()
gg$x$frames <- lapply(gg$x$frames, function(f) {
  f$data <- lapply(f$data, function(d) d[!names(d) %in% c("x", "y")])
  f
})

```

Use police beat for locations instead.

```{r, cache = TRUE}
library(sf)
# Load the community areas boundaries
beat_bounds <- st_read("data/beat_bounds.shp", quiet = TRUE)
beat_bounds %<>% arrange(as.integer(beat_num))
beat_bounds
# Create a neighbours list
beat_nb <- spdep::poly2nb(beat_bounds, row.names = beat_bounds$beat_num)
names(beat_nb) <- attr(beat_nb, "region.id")
coords <- st_coordinates(st_centroid(st_geometry(beat_bounds)))
plot(st_geometry(beat_bounds), border = "grey")
plot(beat_nb, coords, add = TRUE)
# Construct training data set
beat_dat <- gam_train %>% 
  mutate(beat = factor(beat)) %>%
  count(week, year, beat) %>%
  arrange(year, week, beat)
# Train GAM
ctrl <- gam.control(nthreads = 8)
gam_beat <- gam(n ~ s(as.numeric(week), bs = "cc") + beat,
    data = beat_dat, family = "poisson", control = ctrl)
summary(gam_beat)
```

Comparing the GAM using spatial data and a neighbourhood list with a GAM using community areas as factors.

```{r}
gam_com <- gam(n ~ s(as.numeric(week), bs = "cc") + community_area,
    data = spatial_dat, family = "poisson", control = ctrl)
summary(gam_com)
```


# Using PoissonGAM object

Initialise a `PoissonGAM` object that uses week as the time period, and community_area as the region, over which to aggregate, does not include a neighbourhood list (`community_area` used as a factor), takes `fbi_code` as factor too, and filters out any weeks > 52 for consistency.

It takes `gam_train` as the dataset, which is automatically converted to count data aggregated over the above factors. Fitting is performed in parallel over 7 threads.

```{r}
pg <- PoissonGAM$new(time_period = "week", region = "community_area",
                     crime_type = "fbi_code", include_nb = TRUE, 
                     filter_week = TRUE)
# Fit using gam_train as the dataset 
pg$fit(gam_train, n_threads = 7)
pg$gam_fitted
pg$fit_summary
# Prediction on the same dataset
pg$predict()
pg$predictions
# New object with the same properties as pg
pg1 <- pg
pg1$gam_fitted
# Prediction on test dataset instead 
pg1$predict(gam_test)
pg1$predictions
```